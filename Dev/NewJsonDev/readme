Goal:

Move all communication to a JSON based system.

fclient <-> server: JSON

server <-> Mclient: JSON

and vice versa

If possible, use the same JSON structure for both of those listed above (may need to fill the clients stats with jibberish"
or create a key named readstats that determines if the stats will be read or not)

With these, the server acts purely as a proxy between the mclient & fclient, as such, msg_to refers to the fclient or the mclient,
not the server. (unless the server is the one sending the message that is not spawned from either side). The server connection
details are under conn.

Some final notes on this, make this as flexibel AS POSSIBLE so it's easy to write addons/moduesl for this. AKA like plugins.
I dunno how to properly do that, but the JSON should help.
    idea for this one: There's a collection of known Schema's the server knows. it can try to validate the data it gets
    against each one. If one matches, then its valid etc. (maybe even make it subkeys to tack onto the main JSON back)

    The data would be coming from a sub process or similar within the actual client (would have to be compiled in with actions etc),
    get passed to the server, the server figures out what it is based on that known JSON, then can send the respective data to the fclient


API Calls:
    So, to make it easier all over, the modules will be able to do pre-defined actions via an "api" call in the client.
    ex code:
        # figure out a recursive thing or a loop around this to get each key, keypath is a standin
        if key ps_to_run in keypath[GetUser]:
            output = ps.run(keypath[ps_to_run])
            keypath[result] = output

ex of this data

{
    Main Data {
    }
    ...

    AD-ReconPlugin {
        GetUser {
            ## call this first one an "action", possible actions coudl be command_to_run, ps_to_run, script_to_run, etc, code_to_run?
            ## Make an elif tree inside the client for these "api" calls as well. The modules will work a lot easier by having certain things
            ## to call upon. see API calls above

            "ps_to_run," : "get-aduser", ## this key gets parsed, runs the command and populates the 'result' key
            "result" : "" ## blank until key is populated
        }

        GetPrivs{
            "ps_to_run," : "whoami /privs", ## this key gets parsed, runs the command and populates the 'result' key
            "result" : "" ## blank until key is populated
        }

        ...
    }


}



Ex DESC

{
    ## main items
    Standard { ## think of a beter name for this one
        "general": {
            "action":"friendly_client_login"
            "client_id": "username or client_id",
            "client_type": "friendly or malicious"
        },
        "conn": {
            "client_ip": "ip of SERVER (conenction to server)",
            "client_port": "port connected to on SERVER"
        },
        "msg": {
            "msg_to": "Who the message is going to, NOT server. If bob called a command for mclient, and this is mclient calling back, this feild woudl be 'bob' ",
            "msg_content": "Contents of the command/info/data being sent, or returned. i.e. run-ps-command whoami",  ###NOTE!! Phase OUT the \|/, however keep in the current parsing of split on spaces. make it so items with a space should have a "" around them [regex: tokens = re.findall(r'"[^"]*"|\S+', text) ]
                                                                                                                       #### ORRR... just strip the "run-command-ps" part out, and run the remaining text? idk
            "msg_length": "length of the message",
            "msg_hash": "hash of message (later)"
        },
        "stats": {
            "latest_checkin": "time.now",
            "device_hostname": "hostname",
            "device_username": "username"
        },
        "security": {
            "client_hash": "hash of client (later)",
            "server_hash": "hash of server (later)"
        }
    }

    ## optional add in modules
    Module1...

    Module2...
}



Ex FCLIENT:

{
	"general": {
		"client_id": "superman",
		"client_type": "fclient"
	},
	"conn": {
		"client_ip": "127.0.0.1",
		"client_port": "6969"
	},
	"msg": {
		"msg_to": "server", (or CLIENT ID)
		"msg_content": "maliciouspayloadfilecontents",
		"msg_length": "50",
		"msg_hash": ""
	},
	"stats": {
		"latest_checkin": "time.now",
		"device_hostname": "hostname",
		"device_username": "username"
	},
	"security": {
		"client_hash": "test",
		"server_hash": "test"
	}
}

Ex MCLIENT:

{
	"general": {
		"client_id": "IIEQD",
		"client_type": "client"
	},
	"conn": {
		"client_ip": "server-ip",
		"client_port": "2000"
	},
	"msg": {
		"msg_to": "fclient",
		"msg_content": "results_of_malicious_payload",
		"msg_length": "500",
		"msg_hash": ""
	},
	"stats": {
		"latest_checkin": "time.now",
		"device_hostname": "hostname",
		"device_username": "username"
	},
	"security": {
		"client_hash": "test",
		"server_hash": "test"
	}
}

## Delim ":
{
  "mydata": "some \"data\" here"
}
basically:
replace('"','\"')