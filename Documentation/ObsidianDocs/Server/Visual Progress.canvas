{
	"nodes":[
		{"type":"text","text":"## Server","id":"96b86f9b118fcdb7","x":-100,"y":-220,"width":250,"height":60},
		{"type":"text","text":"## C# Client","id":"18203214e329cbe9","x":-920,"y":-220,"width":250,"height":60},
		{"type":"text","text":"## Legend\n## Green: feature working as expected\n## Blue: Beta, should be working, still may break\n## Purple: in Progress\n\n## No Line: Not Implemented\n\nThis is a rough mind map/tracker  of the current setup of the server/client relationship","id":"4b826840d3403f38","x":-670,"y":-680,"width":600,"height":280},
		{"type":"text","text":"Connection is good to go","id":"ea8518d6f1ce0d90","x":-520,"y":-280,"width":250,"height":60},
		{"type":"text","text":"Creating data to send","id":"dac0d47090bc9c51","x":-1240,"y":-220,"width":250,"height":60},
		{"type":"text","text":"## Send Method","id":"13875304f02171ea","x":-1115,"y":100,"width":250,"height":60},
		{"type":"text","text":"## Recv Method","id":"0866e094e0f7be27","x":-795,"y":100,"width":250,"height":60},
		{"type":"text","text":"## Process","id":"e3ec368f02634178","x":-990,"y":300,"width":250,"height":60},
		{"type":"text","text":"## Recv Method","id":"7b642fe3256541de","x":-160,"y":100,"width":250,"height":60},
		{"type":"text","text":"## Send Method","id":"7814a9b67d0d2e82","x":315,"y":240,"width":250,"height":60,"color":"4"},
		{"type":"text","text":"MaliciousClient Handling\n- see --->","id":"16ca1bbb546fcd8e","x":260,"y":-100,"width":360,"height":90,"color":"5"},
		{"type":"file","file":"Server/1. ClientEngine/MaliciousClientHandler Docs/ToDo (old).md","id":"333017d2373b5656","x":780,"y":-1120,"width":400,"height":100},
		{"type":"text","text":"## Todo\nNotes: DB queue works while queue is empty\n\n\n- [x]  DB queue handler needs some work.\n\t- [x] Better method naming\n\t- [x] Proper functions for getting the id of items in queue\n\t- [x] Just a general re-eval. \n\t- [x] Goal: Client just calls the method it needs, and passes the client_name. handler does the rest\n\n\n- [x] Test DB queue while queue has items in it\n- [x] Implement response handling for the MClientHandler, enter responses in DB\n - [ ] Document queue & queue code, along with rationale (see data persistence above)","id":"a711cadb7699fdfa","x":620,"y":-165,"width":500,"height":435},
		{"type":"text","text":"##  Data Persistence (done)\n- SQLite Implementation:\n\t- 4 columns, \n\t\t- msg_id: ID of message for tracking\n\t\t- msg: msg to client (aka queue)\n\t\t- response: response from client\n\t\t- requestor: who queued the msg\n\t- Each listerner would have its own DB (for much later)\n\t- DB would work like queue. Client Handler pops it's respective table, gets the latest command (row), which is sent to the client. Client responds, and that response is written to the same row (tracked with msg_id). \n\t- NOTE: Queue tracking may be an issue, especially if I store all the msg/responses. 2 solutions:\n\t\t- 1) If response != None: Not in queue (aka already been responded to/run)\n\t\t- 2) Add a dedicated key that says if it's in the queue or not","id":"71dccaeb44c6bfeb","x":520,"y":-710,"width":440,"height":60},
		{"type":"text","text":"- [ ] Think about Malleable Profiles, and how they can fit in the sending/receiving part of the server\n\t- [ ] Randomized sleep times...\n\t- [ ] Randomized padding characters to change signatures/message size","id":"0d2d1379b8ed44c7","x":10,"y":-770,"width":390,"height":240},
		{"type":"text","text":"F Client Handling","id":"b3914609fc500828","x":1400,"y":-250,"width":250,"height":60},
		{"type":"text","text":"## Process todo\n\n- [ ] Build out CaseSwitch\n\t- [ ] Consistent code, such as ToJson, Error handling, returning correctly, etc\n- [ ] Clean up the dumb old code/extra comments\n- [ ] DOCUMENT CaseSwitch (chatGPT)\n- [x] Document Main Loop (ChatGPT)\n- [x] Update Canvas Doc the [Main Loop ](obsidian://open?vault=ObsidianDocs&file=Clients%2FCSharp%2FHigh%20Level%20Operation%20Flow.canvas)\n\t- [x] Functions & Name (partially done)\n\t- [ ] Colors\n\n- [ ] PYTHONSIDE\n\t- [x] Fix the bandaid \\dict\\_ and \\raw\\_ responses from server. Think about it, I'd rather not have both passed if possible.\n\t- [x]  Who should be doing JSON decoding? Server, MClientHand, or DBHandler? (first instinct is DBHandler returning a dict, keeps the Mclient handler cleaner)\n\t\t- Just having the MCLient Handler take care of it. Easier to implement\n\t- [ ] Docutmnet a data flow, of how the data is represented (ie: dict -> str -> encoded bytes -> str, and so on. Make this a canvas with each function name)","id":"d978e2c8574e586b","x":-1412,"y":300,"width":345,"height":740}
	],
	"edges":[
		{"id":"3d7527f4f0b5be61","fromNode":"18203214e329cbe9","fromSide":"right","toNode":"7b642fe3256541de","toSide":"left","color":"4"},
		{"id":"da81cb3b57fa493a","fromNode":"96b86f9b118fcdb7","fromSide":"right","toNode":"16ca1bbb546fcd8e","toSide":"top","color":"5"},
		{"id":"ea9f37387990181c","fromNode":"13875304f02171ea","fromSide":"top","toNode":"18203214e329cbe9","toSide":"bottom","color":"4"},
		{"id":"e09e4d843a4f8e81","fromNode":"7b642fe3256541de","fromSide":"right","toNode":"96b86f9b118fcdb7","toSide":"bottom","color":"4"},
		{"id":"2ba1120022a59151","fromNode":"96b86f9b118fcdb7","fromSide":"top","toNode":"b3914609fc500828","toSide":"top"},
		{"id":"511ddc262c1703be","fromNode":"96b86f9b118fcdb7","fromSide":"top","toNode":"0d2d1379b8ed44c7","toSide":"bottom","fromEnd":"arrow"},
		{"id":"1a4672973bd31686","fromNode":"96b86f9b118fcdb7","fromSide":"top","toNode":"71dccaeb44c6bfeb","toSide":"bottom"},
		{"id":"75acf03813b5e9be","fromNode":"16ca1bbb546fcd8e","fromSide":"bottom","toNode":"7814a9b67d0d2e82","toSide":"top","color":"6"},
		{"id":"f9bd7a4154b510e2","fromNode":"e3ec368f02634178","fromSide":"top","toNode":"13875304f02171ea","toSide":"bottom","color":"6"},
		{"id":"9103b3484edd3a6a","fromNode":"7814a9b67d0d2e82","fromSide":"left","toNode":"0866e094e0f7be27","toSide":"right","color":"6"},
		{"id":"905117d59924459c","fromNode":"0866e094e0f7be27","fromSide":"bottom","toNode":"e3ec368f02634178","toSide":"top","color":"6"}
	]
}