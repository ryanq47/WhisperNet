{
	"nodes":[
		{"type":"text","text":"## Server","id":"96b86f9b118fcdb7","x":-100,"y":-220,"width":250,"height":60},
		{"type":"text","text":"## C# Client","id":"18203214e329cbe9","x":-920,"y":-220,"width":250,"height":60},
		{"type":"text","text":"## Legend\n## Green: feature working as expected\n## Purple: in Progress\n\n## No Line: Not Implemented","id":"4b826840d3403f38","x":-670,"y":-680,"width":600,"height":280},
		{"type":"text","text":"Connection is good to go","id":"ea8518d6f1ce0d90","x":-520,"y":-280,"width":250,"height":60},
		{"type":"text","text":"Creating data to send","id":"dac0d47090bc9c51","x":-1240,"y":-220,"width":250,"height":60},
		{"type":"text","text":"## Send Method","id":"13875304f02171ea","x":-1115,"y":100,"width":250,"height":60},
		{"type":"text","text":"## Recv Method","id":"0866e094e0f7be27","x":-795,"y":100,"width":250,"height":60},
		{"type":"text","text":"## Process","id":"e3ec368f02634178","x":-990,"y":300,"width":250,"height":60},
		{"type":"text","text":"## Recv Method","id":"7b642fe3256541de","x":-160,"y":100,"width":250,"height":60},
		{"type":"text","text":"## Send Method","id":"7814a9b67d0d2e82","x":315,"y":240,"width":250,"height":60},
		{"type":"text","text":"F Client Handling","id":"b3914609fc500828","x":1220,"y":-165,"width":250,"height":60},
		{"type":"text","text":"MaliciousClient Handling\n- see --->","id":"16ca1bbb546fcd8e","x":260,"y":-100,"width":360,"height":90},
		{"type":"text","text":"- [ ] Think about Malleable Profiles, and how they can fit in the sending/receiving part of the server","id":"0d2d1379b8ed44c7","x":10,"y":-700,"width":250,"height":120},
		{"type":"text","text":"## Data Persistence\n- SQLite Implementation:\n\t- 4 columns, \n\t\t- msg_id: ID of message for tracking\n\t\t- msg: msg to client (aka queue)\n\t\t- response: response from client\n\t\t- requestor: who queued the msg\n\t- Each listerner would have its own DB (for much later)\n\t- DB would work like queue. Client Handler pops it's respective table, gets the latest command (row), which is sent to the client. Client responds, and that response is written to the same row (tracked with msg_id). \n\t- NOTE: Queue tracking may be an issue, especially if I store all the msg/responses. 2 solutions:\n\t\t- 1) If response != None: Not in queue (aka already been responded to/run)\n\t\t- 2) Add a dedicated key that says if it's in the queue or not","id":"71dccaeb44c6bfeb","x":260,"y":-795,"width":440,"height":430},
		{"type":"file","file":"Server/MaliciousClientHandler Docs/ToDo (old).md","id":"333017d2373b5656","x":780,"y":-1120,"width":400,"height":100},
		{"id":"a711cadb7699fdfa","x":620,"y":-165,"width":500,"height":325,"type":"text","text":"## Todo\nNotes: DB queue works while queue is empty\n\n\n- [ ]  DB queue handler needs some work.\n\t- [ ] Better method naming\n\t- [ ] Proper functions for getting the id of items in queue\n\t- [ ] Just a general re-eval. \n\t- [ ] Goal: Client just calls the method it needs, and passes the client_name. handler does the rest\n\n\n- [ ] Test DB queue while queue has items in it\n- [ ] Implement response handling for the MClientHandler, enter responses in DB\n - [ ] Document queue & queue code, along with rationale (see data persistence above)"}
	],
	"edges":[
		{"id":"3d7527f4f0b5be61","fromNode":"18203214e329cbe9","fromSide":"right","toNode":"7b642fe3256541de","toSide":"left","color":"4"},
		{"id":"da81cb3b57fa493a","fromNode":"96b86f9b118fcdb7","fromSide":"right","toNode":"16ca1bbb546fcd8e","toSide":"top","color":"6"},
		{"id":"ea9f37387990181c","fromNode":"13875304f02171ea","fromSide":"top","toNode":"18203214e329cbe9","toSide":"bottom","color":"4"},
		{"id":"e09e4d843a4f8e81","fromNode":"7b642fe3256541de","fromSide":"right","toNode":"96b86f9b118fcdb7","toSide":"bottom","color":"4"},
		{"id":"2ba1120022a59151","fromNode":"96b86f9b118fcdb7","fromSide":"top","toNode":"b3914609fc500828","toSide":"top"},
		{"id":"511ddc262c1703be","fromNode":"96b86f9b118fcdb7","fromSide":"top","toNode":"0d2d1379b8ed44c7","toSide":"bottom","fromEnd":"arrow"}
	]
}